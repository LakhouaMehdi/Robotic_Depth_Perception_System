import sys

import cv2
import numpy as np


def auto_canny(image, sigma=0.33):
    """
    Detect image edge via Canny Function.

    :param image: ndarray, dtpye=np.uint8
    :param sigma: float
    :return: ndarray edged image
    """

    v = np.median(image)
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)

    return edged


def remove_noise(image, lower, upper):
    """
    Remove noise from image.

    :param image: ndarray
    :param lower: int
    :param upper: int
    :return:
    """
    drawing = np.zeros((image.shape[0], image.shape[1]), dtype=np.uint8)
    for i in range(image.shape[0]):
        for j in range(image.shape[1]):
            if image[i, j] < lower:
                drawing[i, j] = 0
            elif image[i, j] > upper:
                drawing[i, j] = 255
            else:
                drawing[i, j] = image[i, j]
    return drawing


def find_clearance(file_path):
    """
    Return (Side, Clearance) for a image.
    :param file_path: String, image path
    :return: none
    """
    corridor = 60
    crop_area_length_left = 30
    crop_area_length_right = 108
    crop_area_height_top = 120
    crop_area_height_bottom = 60

    img = np.loadtxt(file_path)  # read content from input file
    img_remove_noise = remove_noise(img, 1, 4)
    img_canny = auto_canny(cv2.GaussianBlur(img_remove_noise, (5, 5), 0))
    img_dilate = cv2.dilate(img_canny, None, iterations=2)
    img_erode = cv2.erode(img_dilate, None, iterations=2)

    cropped = np.zeros((img.shape[0], img.shape[1]), dtype=np.uint8)
    cropped[crop_area_length_left:crop_area_length_right, crop_area_height_bottom:crop_area_height_top] = \
        img_erode[crop_area_length_left:crop_area_length_right, crop_area_height_bottom:crop_area_height_top]

    img_contour, contour, hierarchy = cv2.findContours(cropped, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    contour = sorted(contour, key=cv2.contourArea, reverse=True)[:1]
    contour_poly = [None] * len(contour)
    bounding_box = [None] * len(contour)
    for i, c in enumerate(contour):
        contour_poly[i] = cv2.approxPolyDP(c, 3, True)
        bounding_box[i] = cv2.boundingRect(contour_poly[i])

    left = bounding_box[0][0] - 60
    right = 120 - (bounding_box[0][0] + bounding_box[0][2])
    # print("left", left * 1.5 / corridor) if (left > right) else print("right", right * 1.5 / corridor)
    return ("Left", left * 1.5 / corridor) if (left > right) else ("Right", right * 1.5 / corridor)


def find_clearance_2(file_path):
    """

    Reference: https://github.com/wyxPatrick/human-corridor

    :param file_path:
    :return:
    """

    image = np.loadtxt(file_path)

    depth = image / 2
    depth[depth > 5] = 5

    # "background" is generated by stitching image0 and image2 together to
    # cut off the human in the image
    background = np.loadtxt('background.txt')
    human = depth - background

    # Filter the noise points and generate the mask of human
    kernel = np.ones((2, 2), np.uint8)
    opening = cv2.morphologyEx(human, cv2.MORPH_OPEN, kernel)
    human_mask = cv2.erode(opening, kernel, iterations=1)
    human_mask[human_mask > -2.1] = 0
    human_mask[human_mask < -3.3] = 0
    human_mask[human_mask < 0] = 1

    # Use sliding window to detect human in the mask to get rid of the rest
    # of the noise points
    filtered = np.zeros((58, 152))
    window_x = 75
    window_y = 25
    for x in range(human_mask.shape[0] - window_x):
        for y in range(human_mask.shape[1] - window_y):
            filtered[x][y] = np.sum(human_mask[x:x + window_x, y:y + window_y])

    # From the mask of human and the depth image, calculating the depth of
    # human
    human_x = np.where(filtered == np.max(filtered))[0][0]
    human_y = np.where(filtered == np.max(filtered))[1][0]
    human_depth_store = []
    for i in range(human_x, human_x + window_x):
        for j in range(human_y, human_y + window_y):
            if human_mask[i][j] == 1:
                human_depth_store.append(depth[i][j])
    human_depth = np.average(human_depth_store)

    # Decide the safer side and calculate the clearance
    store = np.where((depth >= human_depth - 0.005) & (depth <= human_depth + 0.005))
    corridor_left = np.min(store[1])
    corridor_right = np.max(store[1])
    left = np.abs(human_y - corridor_left)
    right = np.abs(corridor_right - (human_y + window_y))
    corridor = corridor_right - corridor_left

    # if left > right:
    #     distance = (1.5 / corridor) * left
    #     print("left %.3f" % distance)
    # else:
    #    distance = (1.5 / corridor) * right
    #    print("right %.3f" % distance)

    return ("Left", left * 1.5 / corridor) if (left > right) else ("Right", right * 1.5 / corridor)


def ensemble(result_1, result_2):
    """
    Ensemble 2 methods of calculating results.

    :param result_1: (String, Float)
    :param result_2: (String, Float)
    :return: None
    """
    decision_1, distance_1 = result_1
    decision_2, distance_2 = result_2

    mean = (distance_1 + distance_2) / 2.0

    if decision_1 == decision_2:
        # In this case return the mean of 2 distance_2
        print(str(decision_1) + " %.3f" % mean)
    else:
        if distance_1 <= distance_2:
            print(str(decision_2) + " %.3f" % distance_2)
        else:
            print(str(decision_1) + " %.3f" % distance_1)


if __name__ == '__main__':

    try:
        path = sys.argv[1]
    except IndexError:
        print("Please provide valid file path")

    ensemble(find_clearance(sys.argv[1]), find_clearance_2(sys.argv[1]))
